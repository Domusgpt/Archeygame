import React, { useState, useRef, useEffect, useCallback } from 'react';

const ArcheryGame = () => {
  const [arrows, setArrows] = useState([]);
  const [aimAngle, setAimAngle] = useState(0);
  const [playerPosition, setPlayerPosition] = useState(50);
  const [arrowsLeft, setArrowsLeft] = useState(10);
  const [enemiesHit, setEnemiesHit] = useState(0);
  const [level, setLevel] = useState(1);
  const [enemies, setEnemies] = useState([]);
  const [obstacles, setObstacles] = useState([]);
  const [doorVisible, setDoorVisible] = useState(false);
  const [isCharging, setIsCharging] = useState(false);
  const [chargeStartTime, setChargeStartTime] = useState(0);
  const [stars, setStars] = useState([]);
  const [chargePower, setChargePower] = useState(0);
  const [showVictoryMessage, setShowVictoryMessage] = useState(false);

  const gameAreaRef = useRef(null);

  const MAX_CHARGE_TIME = 3000; // 3 seconds
  const BASE_SPEED = 30;
  const BASE_GRAVITY = 15;

  const generateEnemies = useCallback(() => {
    const newEnemies = [];
    for (let i = 0; i < 3 + level; i++) {
      newEnemies.push({
        id: Date.now() + i,
        x: Math.random() * 80 + 10,
        y: Math.random() * (30 + level * 5) + 20,
        width: 5,
        height: 5,
        isHit: false,
        hitTime: 0,
      });
    }
    setEnemies(newEnemies);
  }, [level]);

  const generateObstacles = useCallback(() => {
    const newObstacles = [];
    for (let i = 0; i < level; i++) {
      newObstacles.push({
        id: Date.now() + i,
        x: Math.random() * 80 + 10,
        y: Math.random() * 40 + 30,
        width: 10,
        height: 3,
        direction: Math.random() > 0.5 ? 0.5 : -0.5,
      });
    }
    setObstacles(newObstacles);
  }, [level]);

  useEffect(() => {
    generateEnemies();
    generateObstacles();
    setArrowsLeft(Math.max(3, 10 - level + 1));
  }, [level, generateEnemies, generateObstacles]);

  useEffect(() => {
    if (enemiesHit >= 3) {
      setDoorVisible(true);
    }
  }, [enemiesHit]);

  const handleAim = (e) => {
    if (gameAreaRef.current) {
      const rect = gameAreaRef.current.getBoundingClientRect();
      const x = (e.clientX || e.touches[0].clientX) - rect.left - playerPosition * rect.width / 100;
      const y = rect.bottom - (e.clientY || e.touches[0].clientY);
      setAimAngle(Math.atan2(y, x));
    }
  };

  const startCharging = (e) => {
    e.preventDefault();
    setIsCharging(true);
    setChargeStartTime(Date.now());
  };

  const shootArrow = (e) => {
    e.preventDefault();
    if (arrowsLeft > 0 && isCharging) {
      const chargeTime = Math.min(Date.now() - chargeStartTime, MAX_CHARGE_TIME);
      const chargeFactor = Math.min(chargeTime / 1000, 3);
      const power = Math.pow(2, chargeFactor - 1); // 0.5, 1, 2, or 4
      
      const speed = BASE_SPEED * power;
      const gravity = BASE_GRAVITY / power;

      const newArrow = {
        id: Date.now(),
        x: playerPosition,
        y: 15,
        angle: aimAngle,
        speed: speed,
        gravity: gravity,
        time: 0,
      };
      setArrows(prevArrows => [...prevArrows, newArrow]);
      setArrowsLeft(prevArrows => prevArrows - 1);
      setIsCharging(false);
      setChargePower(0);
    }
  };

  const movePlayer = (direction) => {
    setPlayerPosition(prev => Math.max(0, Math.min(100, prev + direction * 5)));
  };

  const checkCollision = (rect1, rect2) => {
    return rect1.x < rect2.x + rect2.width &&
           rect1.x + rect1.width > rect2.x &&
           rect1.y < rect2.y + rect2.height &&
           rect1.y + rect1.height > rect2.y;
  };

  const handleDoorCollision = () => {
    if (doorVisible && Math.abs(playerPosition - 90) < 5) {
      setShowVictoryMessage(true);
      setTimeout(() => {
        setShowVictoryMessage(false);
        setLevel(prev => prev + 1);
        setDoorVisible(false);
        setEnemiesHit(0);
        generateEnemies();
        generateObstacles();
      }, 3000);
    }
  };

  useEffect(() => {
    const gameLoop = setInterval(() => {
      const currentTime = Date.now();

      setArrows(prevArrows => 
        prevArrows.map(arrow => {
          const newTime = arrow.time + 0.05; // 50ms in seconds
          const newX = arrow.x + Math.cos(arrow.angle) * arrow.speed * 0.05;
          const newY = arrow.y + (Math.sin(arrow.angle) * arrow.speed - arrow.gravity * arrow.time) * 0.05;
          return { ...arrow, x: newX, y: newY, time: newTime };
        }).filter(arrow => {
          if (arrow.x < 0 || arrow.x > 100 || arrow.y < 0) {
            return false;
          }
          
          let hitSomething = false;

          enemies.forEach((enemy, index) => {
            if (!enemy.isHit && checkCollision(
              { x: arrow.x, y: arrow.y, width: 1, height: 1 },
              enemy
            )) {
              setEnemies(prev => prev.map((e, i) => 
                i === index ? { ...e, isHit: true, hitTime: currentTime } : e
              ));
              setEnemiesHit(prev => prev + 1);
              hitSomething = true;
            }
          });

          obstacles.forEach(obstacle => {
            if (checkCollision(
              { x: arrow.x, y: arrow.y, width: 1, height: 1 },
              obstacle
            )) {
              hitSomething = true;
            }
          });

          return !hitSomething;
        })
      );

      setEnemies(prevEnemies => 
        prevEnemies.filter(enemy => {
          if (enemy.isHit && currentTime - enemy.hitTime > 2000) {
            setStars(prev => [...prev, { x: enemy.x, y: enemy.y, id: Date.now() }]);
            return false;
          }
          return true;
        })
      );

      setObstacles(prevObstacles => 
        prevObstacles.map(obstacle => ({
          ...obstacle,
          x: obstacle.x + obstacle.direction,
        })).map(obstacle => {
          if (obstacle.x <= 0 || obstacle.x >= 100 - obstacle.width) {
            return { ...obstacle, direction: -obstacle.direction };
          }
          return obstacle;
        })
      );

      if (isCharging) {
        const chargeTime = Math.min(currentTime - chargeStartTime, MAX_CHARGE_TIME);
        const newChargePower = (chargeTime / MAX_CHARGE_TIME) * 100;
        setChargePower(newChargePower);
      }

      handleDoorCollision();
    }, 50);

    return () => clearInterval(gameLoop);
  }, [enemies, obstacles, isCharging, chargeStartTime, doorVisible, playerPosition]);

  return (
    <div 
      ref={gameAreaRef}
      className="relative w-full h-96 bg-gray-200 overflow-hidden cursor-crosshair"
      onMouseMove={handleAim}
      onMouseDown={startCharging}
      onMouseUp={shootArrow}
      onTouchStart={startCharging}
      onTouchMove={handleAim}
      onTouchEnd={shootArrow}
    >
      {/* Player */}
      <div 
        className="absolute bottom-0 text-4xl"
        style={{ left: `${playerPosition}%` }}
      >
        {isCharging ? '🏹' : '🧍'}
      </div>
      
      {/* Arrows */}
      {arrows.map(arrow => (
        <div 
          key={arrow.id}
          className="absolute text-2xl"
          style={{
            left: `${arrow.x}%`,
            bottom: `${arrow.y}%`,
            transform: `rotate(${Math.atan2(Math.sin(arrow.angle) * arrow.speed - arrow.gravity * arrow.time, Math.cos(arrow.angle) * arrow.speed)}rad)`,
          }}
        >
          🏹
        </div>
      ))}

      {/* Enemies */}
      {enemies.map(enemy => (
        <div 
          key={enemy.id}
          className={`absolute text-3xl transition-opacity duration-300 ${enemy.isHit ? 'opacity-50' : 'opacity-100'}`}
          style={{
            left: `${enemy.x}%`,
            bottom: `${enemy.y}%`,
          }}
        >
          👺
        </div>
      ))}

      {/* Stars */}
      {stars.map(star => (
        <div 
          key={star.id}
          className="absolute text-2xl"
          style={{
            left: `${star.x}%`,
            bottom: `${star.y}%`,
          }}
        >
          ⭐
        </div>
      ))}

      {/* Obstacles */}
      {obstacles.map(obstacle => (
        <div 
          key={obstacle.id}
          className="absolute text-3xl"
          style={{
            left: `${obstacle.x}%`,
            bottom: `${obstacle.y}%`,
          }}
        >
          🪨
        </div>
      ))}

      {/* Door */}
      {doorVisible && (
        <div className="absolute bottom-0 right-0 text-4xl">
          🚪
        </div>
      )}

      {/* UI */}
      <div className="absolute top-0 left-0 p-4 text-black">
        <p>Level: {level}</p>
        <p>Arrows: {arrowsLeft}</p>
        <p>Enemies Hit: {enemiesHit}/3</p>
      </div>

      {/* Controls */}
      <div className="absolute bottom-0 left-0 w-full p-4 flex justify-between">
        <button className="px-4 py-2 bg-gray-500 text-white" onTouchStart={() => movePlayer(-1)} onMouseDown={() => movePlayer(-1)}>Left</button>
        <button className="px-4 py-2 bg-gray-500 text-white" onTouchStart={() => movePlayer(1)} onMouseDown={() => movePlayer(1)}>Right</button>
      </div>

      {/* Victory Message */}
      {showVictoryMessage && (
        <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-50 text-white text-2xl">
          <p>Win ☠️ Arrr 🦜 Win-R Chick 🐥 inn 🏨 🍽️ Din-R</p>
        </div>
      )}
    </div>
  );
};

export default ArcheryGame;
